<?php

define('TFA_TEST_SECRET', 'secret');

/**
 * Implements hook_menu().
 */
function tfa_menu() {
  $items['tfa/%/%'] = array(
    'title' => 'Final authentication',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tfa_code_form', 1, 2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_perm().
 */
function tfa_perm() {
  return array('skip tfa');
}

/**
 * Implements hook_user().
 */
function tfa_user($op, &$edit, &$account, $category = FALSE) {
  global $user;
  if ($op == 'login') {
    // First login operation, send to TFA form.
    // @todo is session best for storing whether tfa was valid?
    // @todo user roles permission based tfa?
    if (!$_SESSION['tfa_code'] && !user_access('skip tfa', $account)) {
      $uid = $user->uid;
      // Destroy the current session.
      session_destroy();
      module_invoke_all('user', 'logout', NULL, $user);
  
      // Force anonymous user.
      $user = user_load(array('uid' => 0));
      unset($_REQUEST['destination']);
  
      $signatory = db_fetch_object(db_query_range('SELECT * FROM {users} WHERE uid = %d', $uid, 0, 1));
      $login_hash = tfa_login_hash($signatory);
      drupal_goto('tfa/' . $signatory->uid . '/' . $login_hash);
      // @todo could also form alter login forms to go multi-step?
    }
  }
}

/**
 * Generate a hash for this account for the TFA login form.
 */
function tfa_login_hash($account) {
  // @todo consider timeouts and better hashing
  return md5($account->name . $account->pass . $account->login);
}

/**
 * Send the code to the user.
 */
function tfa_send_code($account) {
  if (variable_get('tfa_test_mode', TRUE)) {
    $message = variable_get('twilio_pin', '') . ' ' . TFA_TEST_SECRET;
  }
  else {
    // @todo generate code and store
    $message = '';
  }
  // @todo configurable phone/email
  return sms_send($account->profile_phone, $message);
}

/**
 * Retreive sent code for user.
 */
function tfa_get_code($uid) {
  if (variable_get('tfa_test_mode', TRUE)) {
    $code = TFA_TEST_SECRET;
  }
  else {
    // @todo retrieve code
    $code = '';
  }
  return $code;
}

/**
 * Form for code entry.
 */
function tfa_code_form($form_state, $uid, $hash = NULL) {
  // Confirm hash is valid. @todo could account for timeouts.
  $account = user_load(array('uid' => $uid));
  $valid_hash = tfa_login_hash($account);
  if ($hash != $valid_hash) {
    drupal_access_denied();
    exit();
  }

  if (tfa_send_code($account)) {
    // @todo success message
    $form['uid'] = array(
      '#type' => 'value',
      '#value' => $uid,
    );
    $form['code'] = array(
      '#type' => 'textfield',
      '#title' => t('Code'),
      '#required' => TRUE,
    );
    $form['login'] = array(
      '#type' => 'submit',
      '#value' => t('Log in'),
    );
  }
  else {
    // @todo error message
    drupal_set_message(t('There was an error sending the code.'));
    drupal_goto('user');
  }

  return $form;
}

/**
 * Validate handler for TFA login form.
 */
function tfa_code_validate($form, &$form_state) {
  // Validate code.
  // @todo is it possible to alter the UID client-site and flood out another user?
  $code = tfa_get_code($form_state['values']['uid']);
  if ($code != TFA_TEST_SECRET) {
    form_set_error('code', t('Invalid code.'));
    // @todo flood control
  }
}

/**
 * Submit handler for TFA login form.
 */
function tfa_code_submit($form, &$form_state) {
  global $user;

  $uid = $form_state['values']['uid'];
  $account = user_load(array('uid' => $uid));
  $edit = array();
  
  $user = $account;
  // Update the user table timestamp noting user has logged in.
  $user->login = time();
  db_query("UPDATE {users} SET login = %d WHERE uid = %d", $user->login, $user->uid);

  // Regenerate the session ID to prevent against session fixation attacks.
  sess_regenerate();
  $_SESSION['tfa_code'] = TRUE; // @todo is session best for storing validation?
  user_module_invoke('login', $edit, $user);
  $form_state['redirect'] = 'user/' . $user->uid; // @todo destination
}
